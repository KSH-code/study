# Preface
- 개발 방법론, 디버깅, 디자인패턴, 알고리즘 등 다양한 소프트웨어 엔지니어링에 대한 논의는 이뤄지고 있고 모두 가치가 있지만, 소프트웨어 디자인에 대한 내용은 딱히 다뤄지지 않았다.
- 많은 사람들은 소프트웨어 디자인이 재능의 영역으로 생각한다. 하지만, 다양한 과학적인 증거로 이 능력은 노력으로 학습을 할 수 있다고 한다.
- 실제로 이 책은 draft, get feedback, rewrite의 iterative process를 통해 학습한다.

# Introduction
- 소프트웨어는 실제 세계의 한계에 영향이 거의 없기 때문에 창의적인 mind가 필요한 영역이다.
- 소프트웨어는 시간이 지남에따라 신기능이 추가되고 관리되고 이로인해 항상 복잡해진다. 따라서 해당 내용들을 감소시키는 것이 필요하다.
  - 복잡성 제거: 코드를 엣지 케이스없이 간단명료하게 만들거나, 또 다른 방법으로는 모듈화가 있다.
- 책의 목표
  1. 복잡성이 왜 중요한지 알고, 프로그램이 불필요한 복잡성을 가질 때 인식하는 방법을 안다.
  2. 복잡성을 줄이는 방법을 안다.
- *내 생각: 이 책은 소프트웨어의 성장을 효율적으로 하는 방법을 중요하게 생각하고, 이를 잘 처리하기 위한 방법을 정리했을 것으로 느껴진다.*

# The Nature of Complexity
- 복잡성: 수정하기 어렵거나 읽기 어려운 것들이다.
- 시스템의 크기에 따라 수정하기 어렵거나 읽기 어려운 것들이 있을 수 있으나, 이 책은 작은 시스템에서도 발생할 수 있는 것들에 대해 논의하고자 한다.
  - C = sum(complexity of part * fraction of time spended working on)
- 복잡성으로 인한 문제들
  - Change amplification
    - 웹 전체 페이지의 배경 색이 변경되는 것을 대응하려면 어떻게 해야할까?
    - *해법 고민해보자*
  - Cognitive load
    - 한 작업을 처리하기 위해 알아야 하는 지식은 어느정도여야 할까? 많이 알아야 한다면 어떤 문제가 생길까?
    - *해법 고민해보자*
  - Unknown unknowns
    - 특정 페이지에서만 적용되는 색깔들은 어떻게 관리해야 할까?
    - *해법 고민해보자*
- 부가적인 문서가 필요하다면 software design측면에서는 red flag이다.
  - simple하지 않고, obvious하지 않기 때문이다.
- 복잡성은 한 번의 큰 문제로 오지 않고, 조금씩 조금씩 쌓여가며 문제를 만든다. 이는 결국 거의 모든 부분을 수정해야할 만큼 문제가 된다.
- *내 생각: 기획을 명확하게 이해하고, 코드가 수정하기 어렵다면 미리 리팩토링을 해야한다. 코드가 수정하기 어렵다고 느끼는 것이 첫 번째의 시작이며 이는 더 좋은 디자인을 선택할 수 있는 기회이기도 하다.*
